<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Justin Garrigus: Projects</title>
    <link rel="stylesheet" href="../style.css">
    <meta name="robots" content="noindex"> 
    <link rel="icon" type="image/x-icon" href="../media/icon.ico">
  </head>
  <body style="webpage">
	
    <div class="main-area"> 
      <div class="title-area">  
        <div style="width: 120px; float: right;"> 
          <img src="../media/profile-pic.jpg" alt="Profile picture"
            class="profile-pic-top">
        </div>
        <div style="width: calc(100% - 120px);">
          <p class="title-text">Justin Garrigus: Projects</p>
          <p class="subtitle-text">
            Master's Student in Computer Science, University of North Texas
          </p> 
        </div>  
      </div>
      <div class="title-area">
        <table class="sidebar-table"> 
          <tr>
            <th style="border-left: 0;">
              <a href="../index.html">Home</a></th>
            <th><a href="../cv/index.html">CV</a></th>
            <th><a href="../research/index.html">Research</a></th>
            <th><a href="./index.html">Projects</a></th>
            <th><a href="../teaching/index.html">Teaching</a></th>
            <th style="border-right: 0;">
              <a href="../cranes/index.html">Cranes</a></th> 
          </tr>
        </table>
      </div> 
    
      <div class="main-content">
      
        <div class="main-section"> 
          <p class="tab-history-text"> 
            &lt; <a href="../index.html" style="color: #8B8B8B">Home</a> &lt; 
            Projects
          </p>

          <p class="main-text">
            This section gives specific examples of <i>non-research</i> 
            projects I've worked on (to see the projects made specifically for 
            research, go <a href="../research/index.html">here</a>. This page 
            might include projects I've worked on for classes, but there are 
            several I've done only for fun (but only the best/most 
            representative of these are shown). 
          </p> 
          
          <p class="main-text"> 
            <table class="main-table"> 
              <tr>
                <th>Title</th>
                <th>Date</th>
                <th>Type</th>
                <th>Status</th>
              </tr>
              <tr> 
                <td>Arch Linux Personal Computer</td>
                <td>January&nbsp;2024 to current</td> 
                <td>Fun</td> 
                <td>In progress</td>
              </tr> 
              <tr> 
                <td>Computer Security: Image-based Ransomware through Buffer 
                  Overflows and Steganography</td> 
                <td>August&nbsp;2023 to December&nbsp;2023</td> 
                <td>School</td> 
                <td>Complete</td>
              </tr> 
              <tr>
                <td>Empirical Analysis: Study of Life-like Cellular Automata
                  </td> 
                <td>August&nbsp;2023 to December&nbsp;2023</td> 
                <td>School</td>
                <td>Complete</td> 
              </tr>
              <tr>
                <td>Algorithms: Review of Classical Verification of Quantum 
                  Computations in Linear Time</td> 
                <td>August&nbsp;2023 to December&nbsp;2023</td> 
                <td>School</td> 
                <td>Complete</td> 
              </tr>
              <tr>
                <td>Deep Learning: Creating a Programming Language from Neural 
                  Turing Machines</td> 
                <td>January&nbsp;2023 to May&nbsp;2023</td> 
                <td>School</td>
                <td>Complete</td>
              </tr> 
              <tr>
                <td>Parallel Processing: Polyhedral Compilation</td> 
                <td>January&nbsp;2023 to May&nbsp;2023</td> 
                <td>School</td> 
                <td>Complete</td> 
              </tr> 
              <tr>
                <td>Undergraduate Thesis: Syntax as a Tool of Thought</td>
                <td>January&nbsp;2022 to December&nbsp;2022</td>
                <td>School</td> 
                <td>Complete</td> 
              </tr> 
            </table> 
          </p>
        </div>
        
        <div class="main-section" id="arch">
          <p class="main-text-h2">Arch Linux Personal Computer</p> 
          <p class="main-text"><u>Status</u>: in progress (when is this ever 
            <i>not</i> in progress?)</p> 
          <p class="main-text"><u>Timeline</u>: January 2024 to current</p>
          <p class="main-text"> 
            There's an adage that "Linux is free if you don't value your time", 
            and unfortunately, this is even more so with Arch Linux. The amount
            of work this operating system requires would suprise most people, 
            and you might take some things for granted unless you've worked in 
            an environment with much less support compared to Windows (e.g., 
            NVIDIA pushed an update one time that caused Arch systems to stall 
            when their lids are closed). Although, working in Arch Linux 
            is much more enjoyable from a programming and customization 
            perspective; the "everything is a file" design means linking 
            disjoint processes and devices together is very simple, and the 
            open-source nature of the operating system means I can (in 
            principle) control everything that goes on in my computer. It's 
            fun!  
          </p>
        </div> 
        
        <div class="main-section">
          <p class="main-text-h2">Computer Security: Image-based Randomware
            through Buffer Overflows and Steganography</p> 
          <p class="main-text"><u>Status</u>: complete
            (<a href="./media/ransomware-report.pdf" 
            target="_blank">report</a>)</p> 
          <p class="main-text"><u>Timeline</u>: August 2023 to December 2023
            </p>
          <p class="main-text"><u>Professor</u>: Dr. Kirill Morozov</p>
          <p class="main-text"> 
            This was a fun project where we had to create a ransomware (in a 
            virtual environment) that encrypted files with a hidden private key
            and then decrypt those files at a later date. I wanted to do 
            something weirder than a standard privilege escalation or 
            something, so I made my own image-viewing application with a buffer 
            overflow vulnerability in it. It would read images as "ppm" files, 
            and would use an unbounded "strcpy" operation that would create and 
            execute an arbitrary executable file if the attacker hid binary 
            code within the pixels of an image. It's based off of a real attack 
            done against the Korean version of a 2003 Windows operating system! 
            Alongside this, I also wanted to manually implement RSA encryption, 
            which involved creating my own prime-number generator in C without 
            any external libraries.
          </p>
          <details> 
            <summary class="main-text-details">Specific contributions</summary>
            <ul class="main-text-list-indent">
              <li>Demonstrated how a malicious image input to a vulnerable 
                image-viewing application might lead to encryption of 
                arbitrary files on a host computer.</li>
              <li>Showed how the same infected program might unencrypt its
                files once a different modified image is sent by the attacker 
                after the ransom is payed.</li>  
              <li>Re-implemented the Miller-Rabin primality test and RSA 
                encryption/decryption in C without any external libraries.</li>
              <li>Showed how executable files could be encoded within an image
                with least significant bit encoding without being visually 
                perceptible as noise to a human observer.</li>
            </ul> 
          </details>
        </div> 

        <div class="main-section"> 
          <p class="main-text-h2">Empirical Analysis: Study of Life-like 
            Cellular Automata</p> 
          <p class="main-text"><u>Status</u>: complete
            (<a href="./media/cellular-automata-report.pdf" target="_blank"
            >report</a>)</p> 
          <p class="main-text"><u>Timeline</u>: August 2023 to December 2023
            </p>
          <p class="main-text"><u>Professor</u>: Dr. Sayed Shah</p>
          <p class="main-text"> 
            This project only required we use empirical analysis techniques on 
            some dataset. I was (and still am!) really interested in cellular 
            automata at the time, so I used the "state of the grid at each 
            timestep" as a synthetic dataset and performed various statistical 
            analysis methods to show how different life-like cellular automata 
            variants might change their grid in different ways. I liked all the 
            graphs I made! I secretly want to do more projects involving 
            statistical analysis so that I can create and interpret new graphs.
          </p>
          <details> 
            <summary class="main-text-details">Specific contributions</summary>
            <ul class="main-text-list-indent">
              <li>Created a cellular-automata simulator in C that's 
                parallelizable and able to save step-by-step statistics with 
                minimal latency.</li>
              <li>Implemented 11 cellular autoamta variants including Life
                (B3S23), HighLife (B36S23), and Seeds (B2S).</li> 
              <li>Analyzed each simulation step with five functions including 
                Count, Area, and Density.</li> 
              <li>Created a collection of (very) visually-appealing graphs to
                demonstrate how cellular automata change over time to
                characterize traits like chaos and stability.</li>
            </ul> 
          </details>
        </div> 
        
        <div class="main-section"> 
          <p class="main-text-h2">Algorithms: Review of Classical Verification 
            of Quantum Computations in Linear Time</p> 
          <p class="main-text"><u>Status</u>: complete
            (<a href="./media/quantum-report.pdf" target="_blank">report</a>)</p> 
          <p class="main-text"><u>Timeline</u>: August 2023 to December 2023
            </p>
          <p class="main-text"><u>Professor</u>: Dr. Yuan Li</p>
          <p class="main-text"> 
            I had an ulterior motive while completing this project: we were 
            meant to do a thorough review of an article from FOCS, but I wanted
            to additionally learn more about quantum computing. I chose <a 
            href="https://ieeexplore.ieee.org/document/9996633" target="_blank"
            >one of the only quantum papers at this conference</a>, which is 
            <i>not</i> a very 
            good introduction to the topic! I read a few other books at the
            same time to help piece things together--including Quantum Physics: 
            What Everyone Needs to Know by Michael G. Raymer (whom I attended a 
            seminar of in 2023!)--and this presentation became both an 
            introduction of quantum physics to the layman audience and a paper
            review like it was supposed to be in the first place. 
          </p>
          <details> 
            <summary class="main-text-details">Specific contributions</summary>
            <ul class="main-text-list-indent">
              <li>Gave a complete introduction to the realm of quantum physics 
                throughout history, including the Bohr v. Einstein debates and 
                Shrodinger's equation.</li>
              <li>Showed how quantum systems might give more security through 
                observations that change the state of the quantum object 
                without being copied.</li> 
              <li>Summarized the paper, which was really about how we could 
                offload quantum computing work to a computing system while 
                maintaining security and ensure the computing system is 
                actually using quantum computers instead of simulating it.</li>
            </ul> 
          </details>
        </div> 

        <div class="main-section"> 
          <p class="main-text-h2">Deep Learning: Creating a Programming 
            Language from Neural Turing Machines</p> 
          <p class="main-text"><u>Status</u>: complete
            (<a href="./media/ntm-report.pdf" target="_blank">report</a>)</p> 
          <p class="main-text"><u>Timeline</u>: January 2023 to May 2023</p>
          <p class="main-text"><u>Professor</u>: Dr. Heng Fan</p>
          <p class="main-text"> 
            This project wanted us to implement a deep-learning system on a 
            new dataset or task. Around the same time I was interested in 
            programming language design and the concept of domain-specific
            languages (especially esolangs), and wondered if it was possible to
            create a programming language that would be capable of learning 
            algorithms built from individual discrete instructions, where
            a human supplies the target inputs/outputs to the algorithm and the
            model learns which instructions to activate in which order to make
            that algorithm. The algorithm-learner turned out to be more 
            complicated of a task than I could do in a semester (and it's
            something transformers have already accomplished, in either case), 
            so I pivoted to making a programming language instead: the user
            passes in a list of instructions as plaintext, and the model 
            executes each by passing each through a list of sub-models (with 
            each trained to implement an individual instruction). The langauge
            works, but is very limited in types of programs it's able to 
            accomplish.
          </p>
          <details> 
            <summary class="main-text-details">Specific contributions</summary>
            <ul class="main-text-list-indent">
              <li>Trained one Neural Turing Machine for each instruction in a 
                predefined instruction-set. Neural Turing Machines are able to 
                generalize significantly better for inputs of longer lengths
                compared to other types of recurrent networks like LSTMs.</li>
              <li>Created a language-parser that turns a string in plaintext
                into a list of softmaxed coefficients.</li> 
              <li>Implemented a REPR used as an interface to the language.</li> 
            </ul> 
          </details>
        </div> 

        <div class="main-section"> 
          <p class="main-text-h2">Parallel Processing: Polyhedral 
            Compilation</p> 
          <p class="main-text"><u>Status</u>: complete
            (<a href="./media/polyhedral-report.pdf" 
            target="_blank">report</a>)</p> 
          <p class="main-text"><u>Timeline</u>: January 2023 to May 2023</p>
          <p class="main-text"><u>Professor</u>: Dr. Song Fu</p>
          <p class="main-text"> 
            The polyhedral approach to compilation is a technique where a loop
            in a program is transformed into an equivalent representation that
            reduces the value dependencies between loop iterations. It 
            visualizes array accesses as a function dependent on an affine 
            iterator value, and uses the polyhedral method to skew, translate, 
            or shift the affine polyhedra to make the dependencies a different
            shape with respect to iterator. This project creates my own 
            polyhedral optimizer with the help of different polyhedra-specific
            libraries like OpenScop, Clan, and CLooG. Although, I didn't 
            realize at the time that this takes a good background in math to
            understand how to do it! Specifically, loops require the 
            calculation of a special matrix through a linear-equation solver, 
            which is difficult to compute without knowing what the "Farkas 
            lemma" was (which I didn't...). My solution was to randomize this 
            matrix, compiling the resulting program, and running a collection 
            of tests to ensure the final program was still semantically 
            correct. This means the compiler has the possibility of generating
            programs that don't match what the programmer intended (so it
            should not be used in the real-world), but it does generate 
            programs that are significantly faster in certain cases!
          </p>
          <details> 
            <summary class="main-text-details">Specific contributions</summary>
            <ul class="main-text-list-indent">
              <li>Used the OpenScop, Clan, and CLooG libraries in C to create
                a polyhedral program optimizer.</li>
              <li>Extracted valid optimizable code from target programs, pipes
                it through the compiler, and replaces the original code with 
                the optimized code.</li>
              <li>Created a random optimizer that repeatedly attempts random 
                program variants until the highest-performing version is found
                within a given time period.</li>
            </ul> 
          </details>
        </div> 

        <div class="main-section" id="thesis"> 
          <p class="main-text-h2">Undergraduate Thesis: Syntax as a Tool of 
            Thought</p> 
          <p class="main-text"><u>Status</u>: complete 
            (<a href="./media/senior-thesis.pdf" target="_blank">report</a>)
            </p> 
          <p class="main-text"><u>Timeline</u>: January 2022 to December 2022
            </p>
          <p class="main-text"><u>Advisor</u>: Dr. Barrett Bryant</p>
          <p class="main-text"> 
            This was my final requirement for completing my Bachelor's degree.
            I started it with Dr. Barrett Bryant in his class on compilers as 
            a step in graduating with Honor's, and it led into an entire thesis
            in the following semester. It's composed of two parts: first, an
            analysis on programming languages and their ability to solve 
            domain-specific problems; and second, the introduction of a new 
            programming language created by me which demonstrates flexibility 
            in syntactical design as to accommodate different kinds of 
            domain-specific problems. The thesis is submitted alongside a 
            compiler (lexical, syntactical, and semantic analysis) and an 
            interpreter for 
            the language, both written in standard Python. The language is 
            designed around allowing the user to create their own syntactic 
            constructs, with things like for-loops and if-statements not being
            defined in the language by default. The user can create functions 
            that utilize a bytecode to implement these important constructs 
            and any more the programmer might need. The end result of this is 
            that very diverse problems can be elegantly represented in the 
            language in the format they naturally relate to; I demonstrate this
            by creating a program that looks nearly identical to SQL, which 
            the programmer implemented as a result of defining a significant 
            portion of the SQL syntax from within the new language.
          </p>
          <details> 
            <summary class="main-text-details">Specific contributions</summary>
            <ul class="main-text-list-indent">
              <li>Created a programming language that demonstrates an extremely
                flexible design, allowing it to accommodate to many different 
                kinds of domain-specific problems.</li>
              <li>Implemented a compiler (lexical, syntax, and semantic 
                analysis) that turns a source file into a bytecode 
                representation, which can be executed with an additional 
                interpreter.</li> 
              <li>Created representative examples of this programming language
                simplifying the source code required to solve complex problems
                that do not translate well from their original domain-specific 
                representations.</li>
              <li>Learned how the research process works by reading papers and
                forming an argument, eventually culminating in a polished 
                report.</li> 
            </ul> 
          </details>
        </div> 

      </div>

      <div class="last-updated"> 
        <p class="last-updated-text">
          Last updated August 22, 2024 at 6:43pm CST
       </p>
      </div>  

    </div>

    <div class="sidebar">
      <img src="../media/profile-pic.jpg" alt="Profile Picture" 
        class="profile-pic">
      <p class="sidebar-text">
        <img src="../media/bullets/1.png", style="height: 1em">
        <a href="../index.html">Home</a></p>
      <p class="sidebar-text">
        <img src="../media/bullets/2.png", style="height: 1em">
        <a href="../cv/index.html">CV</a></p>
      <p class="sidebar-text">
        <img src="../media/bullets/3.png", style="height: 1em">
        <a href="../research/index.html">Research</a></p>
      <p class="sidebar-text">
        <img src="../media/bullets/4.png", style="height: 1em">
        <a href="./index.html">Projects</a></p> 
      <p class="sidebar-text">
        <img src="../media/bullets/5.png", style="height: 1em">
        <a href="../teaching/index.html">Teaching</a></p> 
      <p class="sidebar-text">
        <img src="../media/bullets/6.png", style="height: 1em">
        <a href="../cranes/index.html">Cranes</a></p>
    </div>
  
  </body>
</html>
